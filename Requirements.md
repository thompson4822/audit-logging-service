# Audit Logging Service Requirements

## 1. Purpose

The Audit Logging Service is a stand-alone microservice designed to receive, store, and provide access to audit log entries generated by other services. It enables traceability, accountability, and compliance by centralizing audit records for actions performed across a distributed system.

---

## 2. Scope

- Accept audit log entries via REST API (and optionally via messaging in the future).
- Store audit logs in a relational database.
- Provide endpoints for querying and filtering audit logs.
- Expose health and metrics endpoints for observability.

---

## 3. Functional Requirements

### 3.1. Audit Log Data Model

Each audit log entry must include:
- **id**: Unique identifier (UUID)
- **timestamp**: When the event occurred
- **serviceName**: Name of the originating service
- **eventType**: Type of event (e.g., CREATE, UPDATE, DELETE, LOGIN, ERROR)
- **entityType**: Type of entity affected (e.g., User, Order)
- **entityId**: Identifier of the affected entity (string/UUID)
- **userId**: Identifier of the user who triggered the event (optional)
- **details**: Free-form JSON or string for event details (e.g., changes, metadata)
- **status**: (Optional) Outcome of the event (e.g., SUCCESS, FAILURE)

---

### 3.2. REST API Endpoints

#### 3.2.1. Submit Audit Log Entry
- **POST /audit-logs**
- Request: JSON body with required fields
- Response: 201 Created with the stored audit log entry

#### 3.2.2. Get Audit Log Entry by ID
- **GET /audit-logs/{id}**
- Response: 200 OK with audit log entry, 404 if not found

#### 3.2.3. Query Audit Logs
- **GET /audit-logs**
- Supports filtering by:
    - `serviceName`
    - `eventType`
    - `entityType`
    - `entityId`
    - `userId`
    - `status`
    - `timestamp` range (from/to)
- Supports pagination (e.g., `page`, `size`)
- Response: 200 OK with paginated list of audit logs

---

### 3.3. Data Integrity & Validation

- Validate required fields and correct data types.
- Reject invalid or incomplete requests with appropriate HTTP status codes.

---

### 3.4. Observability

- Expose health check endpoints (`/q/health`, `/q/health/live`, `/q/health/ready`).
- Expose metrics endpoint (`/q/metrics`), compatible with Prometheus.

---

### 3.5. Error Handling

- Return meaningful error messages and standard HTTP status codes (e.g., 400, 404, 500).
- Log all errors for troubleshooting.

---

## 4. Non-Functional Requirements

- **Performance**: Should handle at least 100 audit log entries per second.
- **Scalability**: Deployable as a containerized service, horizontally scalable.
- **Security**: Ready for integration with authentication/authorization (e.g., API key, OAuth2).
- **Extensibility**: Easy to add new fields to audit log entries.
- **Documentation**: OpenAPI/Swagger documentation auto-generated and available at `/q/openapi`.

---

## 5. Technology Stack

- **Language**: Kotlin
- **Framework**: Quarkus
- **Database**: PostgreSQL (or other JDBC-compatible DB)
- **Persistence**: Hibernate ORM with Panache (Kotlin)
- **API**: REST (JSON)
- **Serialization**: Jackson
- **Containerization**: Docker-ready

---

## 6. Out of Scope

- Real-time alerting or notification on audit events.
- Analytics or reporting dashboards (beyond basic querying).
- Integration with external log management systems (e.g., ELK, Splunk) in the initial version.

---

## 7. Open Questions

- Should the service support bulk log entry submission?
- Is there a need for soft-delete or retention policies for old logs?
- Should audit logs be immutable after creation?
- Will there be a need for integration with message queues for log ingestion?

---

## 8. Success Criteria

- All endpoints function as specified.
- Audit logs can be submitted, queried, and retrieved.
- Can be deployed independently.
- Passes integration and unit tests.
- OpenAPI documentation is accurate and complete.

---

Let me know if youâ€™d like a sample data model, OpenAPI spec, or starter code for this service!

---
Answer from Perplexity: pplx.ai/share